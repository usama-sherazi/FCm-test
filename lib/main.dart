// core Flutter primitives
import 'package:flutter/foundation.dart';
// core FlutterFire dependency
import 'package:firebase_core/firebase_core.dart';
// generated by flutterfire configure
import 'firebase_options.dart';
// FlutterFire's Firebase Cloud Messaging plugin
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'dart:async';
import 'dart:convert';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:shared_preferences/shared_preferences.dart';

// Stream controller for FCM messages
final StreamController<RemoteMessage> messageStreamController = StreamController<RemoteMessage>.broadcast();

// Message storage key
const String _messagesStorageKey = 'saved_fcm_messages';

// Save message to local storage
Future<void> saveMessage(RemoteMessage message) async {
  try {
    final prefs = await SharedPreferences.getInstance();
    final messagesJson = prefs.getStringList(_messagesStorageKey) ?? [];
    
    // Convert message to JSON
    final messageMap = {
      'messageId': message.messageId ?? '',
      'title': message.notification?.title ?? '',
      'body': message.notification?.body ?? '',
      'data': message.data.toString(),
      'timestamp': DateTime.now().toIso8601String(),
      'sentTime': message.sentTime?.toIso8601String() ?? '',
    };
    
    messagesJson.insert(0, jsonEncode(messageMap));
    
    // Keep only last 100 messages to avoid storage issues
    if (messagesJson.length > 100) {
      messagesJson.removeRange(100, messagesJson.length);
    }
    
    await prefs.setStringList(_messagesStorageKey, messagesJson);
    
    if (kDebugMode) {
      print('Message saved to local storage');
    }
  } catch (e) {
    if (kDebugMode) {
      print('Error saving message: $e');
    }
  }
}

// Load saved messages from local storage
Future<List<Map<String, dynamic>>> loadSavedMessages() async {
  try {
    final prefs = await SharedPreferences.getInstance();
    final messagesJson = prefs.getStringList(_messagesStorageKey) ?? [];
    
    return messagesJson.map((json) {
      try {
        return jsonDecode(json) as Map<String, dynamic>;
      } catch (e) {
        return <String, dynamic>{};
      }
    }).toList();
  } catch (e) {
    if (kDebugMode) {
      print('Error loading messages: $e');
    }
    return [];
  }
}

// Clear all saved messages
Future<void> clearSavedMessages() async {
  try {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_messagesStorageKey);
    if (kDebugMode) {
      print('All messages cleared');
    }
  } catch (e) {
    if (kDebugMode) {
      print('Error clearing messages: $e');
    }
  }
}

// Local notifications plugin
final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

// Initialize local notifications
Future<void> initializeLocalNotifications() async {
  if (kIsWeb) return; // Not supported on web

  const AndroidInitializationSettings initializationSettingsAndroid =
      AndroidInitializationSettings('@mipmap/ic_launcher');

  const DarwinInitializationSettings initializationSettingsIOS =
      DarwinInitializationSettings(
    requestAlertPermission: true,
    requestBadgePermission: true,
    requestSoundPermission: true,
  );

  const InitializationSettings initializationSettings = InitializationSettings(
    android: initializationSettingsAndroid,
    iOS: initializationSettingsIOS,
  );

  await flutterLocalNotificationsPlugin.initialize(
    initializationSettings,
    onDidReceiveNotificationResponse: (NotificationResponse response) {
      if (kDebugMode) {
        print('Notification tapped: ${response.payload}');
      }
    },
  );

  // Create notification channel for Android
  const AndroidNotificationChannel channel = AndroidNotificationChannel(
    'high_importance_channel', // id
    'High Importance Notifications', // title
    description: 'This channel is used for important notifications.',
    importance: Importance.high,
    playSound: true,
    enableVibration: true,
  );

  await flutterLocalNotificationsPlugin
      .resolvePlatformSpecificImplementation<
          AndroidFlutterLocalNotificationsPlugin>()
      ?.createNotificationChannel(channel);
}

// Show notification banner with sound
Future<void> showNotificationBanner(RemoteMessage message) async {
  if (kIsWeb) return; // Not supported on web

  const AndroidNotificationDetails androidPlatformChannelSpecifics =
      AndroidNotificationDetails(
    'high_importance_channel',
    'High Importance Notifications',
    channelDescription: 'This channel is used for important notifications.',
    importance: Importance.high,
    priority: Priority.high,
    showWhen: true,
    playSound: true,
    enableVibration: true,
    icon: '@mipmap/ic_launcher',
  );

  const DarwinNotificationDetails iOSPlatformChannelSpecifics =
      DarwinNotificationDetails(
    presentAlert: true,
    presentBadge: true,
    presentSound: true,
  );

  const NotificationDetails platformChannelSpecifics = NotificationDetails(
    android: androidPlatformChannelSpecifics,
    iOS: iOSPlatformChannelSpecifics,
  );

  await flutterLocalNotificationsPlugin.show(
    message.hashCode,
    message.notification?.title ?? 'New Notification',
    message.notification?.body ?? 'You have a new message',
    platformChannelSpecifics,
    payload: message.data.toString(),
  );
}

// Background message handler - must be a top-level function
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  if (kDebugMode) {
    print('Handling a background message: ${message.messageId}');
  }
  
  // Save background message to local storage
  await saveMessage(message);
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Initialize local notifications for banner and sound
  await initializeLocalNotifications();

  // Request permission
  final messaging = FirebaseMessaging.instance;

  final settings = await messaging.requestPermission(
    alert: true,
    announcement: false,
    badge: true,
    carPlay: false,
    criticalAlert: false,
    provisional: false,
    sound: true,
  );

  if (kDebugMode) {
    print('Permission granted: ${settings.authorizationStatus}');
  }

  // Register with FCM
  final token = await messaging.getToken();
  if (kDebugMode) {
    print('FCM Registration Token: $token');
  }

  // Set up foreground message handler
  FirebaseMessaging.onMessage.listen((RemoteMessage message) async {
    if (kDebugMode) {
      print('Got a message whilst in the foreground!');
      print('Message data: ${message.data}');
      if (message.notification != null) {
        print('Message also contained a notification: ${message.notification?.title}');
      }
    }
    
    // Save message to local storage
    await saveMessage(message);
    
    // Show notification banner with sound
    await showNotificationBanner(message);
    
    // Add message to stream for UI display
    messageStreamController.add(message);
  });

  // Set up background message handler
  FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);

  // Subscribe to a topic
  await messaging.subscribeToTopic('all');

  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter FCM',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
        useMaterial3: true,
      ),
      home: const MyHomePage(title: 'Flutter FCM Home Page'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});

  // This widget is the home page of your application. It is stateful, meaning
  // that it has a State object (defined below) that contains fields that affect
  // how it looks.

  // This class is the configuration for the state. It holds the values (in this
  // case the title) provided by the parent (in this case the App widget) and
  // used by the build method of the State. Fields in a Widget subclass are
  // always marked "final".

  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  String? _token;
  final List<RemoteMessage> _messages = [];
  final List<Map<String, dynamic>> _savedMessages = [];
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _getToken();
    _loadSavedMessages();
    _setupMessageListener();
  }

  Future<void> _getToken() async {
    final token = await FirebaseMessaging.instance.getToken();
    setState(() {
      _token = token;
    });
    if (kDebugMode) {
      print('FCM Registration Token: $token');
    }
  }

  Future<void> _loadSavedMessages() async {
    setState(() {
      _isLoading = true;
    });
    
    final saved = await loadSavedMessages();
    
    setState(() {
      _savedMessages.clear();
      _savedMessages.addAll(saved);
      _isLoading = false;
    });
    
    if (kDebugMode) {
      print('Loaded ${_savedMessages.length} saved messages');
    }
  }

  Future<void> _clearAllMessages() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Clear All Messages'),
        content: const Text('Are you sure you want to delete all saved messages?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Clear', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
    
    if (confirmed == true) {
      await clearSavedMessages();
      await _loadSavedMessages();
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('All messages cleared')),
        );
      }
    }
  }

  void _setupMessageListener() {
    messageStreamController.stream.listen((RemoteMessage message) async {
      setState(() {
        _messages.insert(0, message);
      });
      if (kDebugMode) {
        print('Handling a foreground message');
      }
      
      // Reload saved messages to show the new one
      await _loadSavedMessages();
      
      // Show snackbar banner in app
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  message.notification?.title ?? 'New Notification',
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 16,
                  ),
                ),
                if (message.notification?.body != null)
                  Text(
                    message.notification!.body!,
                    style: const TextStyle(fontSize: 14),
                  ),
              ],
            ),
            backgroundColor: Colors.blue.shade700,
            behavior: SnackBarBehavior.floating,
            margin: const EdgeInsets.all(16),
            duration: const Duration(seconds: 4),
            action: SnackBarAction(
              label: 'Dismiss',
              textColor: Colors.white,
              onPressed: () {},
            ),
          ),
        );
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        title: Text(widget.title),
        actions: [
          if (_savedMessages.isNotEmpty)
            IconButton(
              icon: const Icon(Icons.delete_outline),
              tooltip: 'Clear all messages',
              onPressed: _clearAllMessages,
            ),
          IconButton(
            icon: const Icon(Icons.refresh),
            tooltip: 'Refresh messages',
            onPressed: _loadSavedMessages,
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'FCM Registration Token:',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            SelectableText(
              _token ?? 'Loading...',
              style: const TextStyle(fontSize: 12, fontFamily: 'monospace'),
            ),
            const SizedBox(height: 24),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Saved Messages:',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
                if (_savedMessages.isNotEmpty)
                  Text(
                    '${_savedMessages.length} message${_savedMessages.length > 1 ? 's' : ''}',
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 8),
            if (_isLoading)
              const Center(
                child: Padding(
                  padding: EdgeInsets.all(16.0),
                  child: CircularProgressIndicator(),
                ),
              )
            else if (_savedMessages.isEmpty)
              const Text(
                'No messages saved yet.',
                style: TextStyle(fontStyle: FontStyle.italic),
              )
            else
              ..._savedMessages.map((messageData) {
                final timestamp = messageData['timestamp'] as String?;
                final dateTime = timestamp != null
                    ? DateTime.tryParse(timestamp)
                    : null;
                
                return Card(
                  margin: const EdgeInsets.only(bottom: 8),
                  child: Padding(
                    padding: const EdgeInsets.all(12.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Expanded(
                              child: Text(
                                messageData['title'] as String? ?? 'No title',
                                style: const TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ),
                            if (dateTime != null)
                              Text(
                                '${dateTime.day}/${dateTime.month}/${dateTime.year} ${dateTime.hour}:${dateTime.minute.toString().padLeft(2, '0')}',
                                style: TextStyle(
                                  fontSize: 10,
                                  color: Colors.grey[600],
                                ),
                              ),
                          ],
                        ),
                        if (messageData['body'] != null &&
                            (messageData['body'] as String).isNotEmpty) ...[
                          const SizedBox(height: 4),
                          Text(
                            messageData['body'] as String,
                            style: const TextStyle(fontSize: 14),
                          ),
                        ],
                        if (messageData['data'] != null &&
                            (messageData['data'] as String).isNotEmpty &&
                            (messageData['data'] as String) != '{}') ...[
                          const SizedBox(height: 8),
                          const Text(
                            'Data:',
                            style: TextStyle(
                              fontSize: 12,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          Text(
                            messageData['data'] as String,
                            style: const TextStyle(
                              fontSize: 12,
                              fontFamily: 'monospace',
                            ),
                          ),
                        ],
                      ],
                    ),
                  ),
                );
              }),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    // Note: messageStreamController is global and should not be closed here
    super.dispose();
  }
}
